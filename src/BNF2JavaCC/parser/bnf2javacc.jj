/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. bnf2javacc.jj */
/*@egen*//**
 * JJTree template file created by SF JavaCC plugin 1.5.17+ wizard for JavaCC 1.5.0+
 */options{  STATIC = false;               }PARSER_BEGIN(BNF2JavaCC)package BNF2JavaCC.parser;public class BNF2JavaCC/*@bgen(jjtree)*/implements BNF2JavaCCTreeConstants/*@egen*/{/*@bgen(jjtree)*/
  protected JJTBNF2JavaCCState jjtree = new JJTBNF2JavaCCState();

/*@egen*/}PARSER_END(BNF2JavaCC)SPECIAL_TOKEN :{  " "| "\t"| "\n"| "\r"| < "//" (~[ "\n", "\r" ])*    (      "\n"    | "\r"    | "\r\n"    ) >| < "/*" (~[ "*" ])* "*"    (      ~[ "/" ] (~[ "*" ])* "*"    )*    "/" >}TOKEN :{  < LABEL : < ID_FIRST_LETTER > (< OTHER_LETTERS >)* >| < #ID_FIRST_LETTER : [ "a"-"z", "A"-"Z" ] >| < #OTHER_LETTERS :    (      < ID_FIRST_LETTER >    | [ "0"-"9" ]    ) >}ASTGrammar Grammar() :{/*@bgen(jjtree) Grammar */
  ASTGrammar jjtn000 = new ASTGrammar(JJTGRAMMAR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) Grammar */
  try {
/*@egen*/  try  {   (
     Rule()   )*  }  catch (ParseException ex)  {    throw new IllegalStateException("Parsing failed");  }/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    return jjtn000;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}

void Rule():{/*@bgen(jjtree) Rule */
  ASTRule jjtn000 = new ASTRule(JJTRULE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) Rule */
   try {
/*@egen*/
   NonTerminal() "::=" Production()/*@bgen(jjtree)*/
   } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       throw (RuntimeException)jjte000;
     }
     if (jjte000 instanceof ParseException) {
       throw (ParseException)jjte000;
     }
     throw (Error)jjte000;
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
   }
/*@egen*/}void NonTerminal() :{/*@bgen(jjtree) NonTerminal */
  ASTNonTerminal jjtn000 = new ASTNonTerminal(JJTNONTERMINAL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) NonTerminal */
  try {
/*@egen*/  < LABEL >/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}
